# Security module — Summary (authentication, JWT, refresh tokens)

This document describes the authentication-related parts of the RMS `security` module, with emphasis on JWT generation/verification and refresh token logic.

Files reviewed (key classes):
- `security.jwt.JwtService` — central logic for creating access tokens, issuing and rotating refresh tokens, revocation and cleanup.
- `security.jwt.RefreshToken` / `RefreshTokenRepository` / `RefreshTokenProperties` — persistence and configuration for refresh tokens.
- `security.jwt.JwtProperties` — configuration for JWT (key, expiration).
- `security.auth.AuthController` / `security.auth.AuthService` — HTTP endpoints and controller-level cookie handling.
- `security.UserCredentialsProvider` — integration point used by `JwtService` to resolve user credentials during refresh flow.
- `security.jwt.InvalidRefreshTokenException` — error signalled on invalid/expired/unusable refresh tokens.

Summary of authentication flow

- Login
  - Endpoint: POST `/api/v1/auth/login` (controller `AuthController`).
  - The controller calls `AuthService.login(...)` which delegates to Spring Security's `AuthenticationManager` to authenticate username/password.
  - On successful authentication, `JwtService.createTokens(...)` is invoked.
  - `createTokens`:
    - Creates a signed JWT access token containing subject (user id) and a `roles` claim.
    - Generates a secure random refresh token (raw string) and computes a hash of it using a configured `MessageDigest`.
    - Persists a `RefreshToken` entity containing tokenHash, userId, username, expiresAt, createdAt, lastUsedAt, deviceInfo, ipAddress, tokenFamily and revoked=false.
    - Enforces maximum active refresh tokens per user (configured via `refresh-tokens.maxPerUser`) by revoking oldest tokens if needed.
    - Returns a TokenPair: (accessToken, rawRefreshToken). The controller sets the raw refresh token as an HttpOnly secure cookie and returns the access token in the response body.

- Access token (JWT)
  - Created by `JwtService.createAccessToken(Authentication)` using the `Algorithm` bean (injected).
  - Includes subject = authenticated principal id and claim `roles` = list of authorities.
  - Signed and time-limited according to `jwt.expirationMillis` from `JwtProperties`.
  - `JwtService.parseJwt(String token)` verifies the token signature and extracts subject and roles to build a `UserPrincipal`.

- Refresh flow
  - Endpoint: POST `/api/v1/auth/refresh` (controller `AuthController`).
  - The controller reads the refresh token from the `refresh_token` cookie and passes it to `AuthService.refreshTokens(...)`.
  - `JwtService.refreshTokens(rawToken, device, ip)` performs:
    - Hash the provided raw token and look it up in `RefreshTokenRepository.findByTokenHashAndRevokedFalse`.
    - If token not found -> throw `InvalidRefreshTokenException` (401).
    - If token expired -> revoke and throw `InvalidRefreshTokenException`.
    - Check rapid reuse: if lastUsedAt is very recent (< ~5 seconds) then treat as reuse attack: revoke the whole token family and throw `InvalidRefreshTokenException`.
    - Resolve user credentials via `UserCredentialsProvider.getUserCredentials(username)` to obtain authorities and build an Authentication (
      `UserPrincipalAuthenticationToken`). If user missing -> throw `InvalidRefreshTokenException`.
    - Validate device info and IP address from the incoming request match values saved on the refresh token; if mismatch -> throw `RefreshTokenCorruptionException`.
    - Revoke the old refresh token, create a new refresh token record that belongs to the same `tokenFamily`, persist it and return a new TokenPair (new access token and new raw refresh token).
    - The controller sets the new raw refresh token as an HttpOnly secure cookie and returns the new access token in response body.

- Token revocation and rotation
  - Individual token revocation: `JwtService.revokeToken(rawToken)` hashes and revokes the stored token (sets revoked=true and revokedAt).
  - Revoke all of a user's tokens: `JwtService.revokeAllUserTokens(UUID userId)` used e.g. on logout.
  - Token family revocation: `revokeTokenFamily(tokenFamily)` revokes all non-revoked tokens that share the same `tokenFamily` — used on token reuse detection to limit account compromise.
  - Business rule: when a refresh token is used to refresh an access token, the old refresh token is revoked and rotated (a new refresh token is issued) — this reduces the window for stolen refresh tokens.

- Security of refresh tokens
  - Raw refresh tokens are never stored directly. The server stores only a hash of the token (using configured `MessageDigest`).
  - Raw tokens are long, random, URL-safe strings generated by `SecureRandom` and Base64 URL encoding.
  - Stored refresh token row includes `deviceInfo` and `ipAddress` captured from the request; these are validated on refresh to detect corruption or token theft.
  - `tokenFamily` (random UUID string) groups refresh tokens created from the same origin/session; on reuse detection the whole family is revoked to limit attacker lateral use.
  - There is a configurable maximum number of active refresh tokens per user; when exceeded, oldest tokens are revoked to enforce the limit.

- Token reuse detection
  - When a refresh token is used, `JwtService.wasRecentlyUsed` computes time since `lastUsedAt`; if too short (configured threshold: 5 seconds), the code treats this as a likely sign of token replay/reuse and revokes the entire token family, failing the refresh.
  - This is a defensive mechanism designed to detect multiple simultaneous uses of the same token (e.g., an attacker and a legitimate client trying to use the same token) and force re-authentication.

- Persistence and cleanup
  - `RefreshToken` is a JPA entity stored in `refresh_tokens` table with fields for tokenHash, userId, username, timestamps, deviceInfo, ipAddress, revoked flag, tokenFamily and optimistic versioning.
  - `RefreshTokenRepository` provides queries for lookups and a custom modifying query to delete expired tokens and old revoked tokens.
  - `JwtService.cleanupExpiredTokens()` is scheduled (cron: daily at 02:00) and removes tokens by expiry or old revokedAt timestamp using `deleteByExpiresAtBeforeOrRevokedAtBefore`.

- Configuration
  - `JwtProperties` (prefix `jwt`): holds `key` and `expirationMillis`.
  - `RefreshTokenProperties` (prefix `refresh-tokens`): holds `length` (number of random bytes used to generate raw token), `maxPerUser` and `validityDays`. A helper method returns `Duration` for the validity.
  - Other required beans (injection points seen in `JwtService`): `Algorithm` (for signing JWTs), `Clock`, `SecureRandom`, `MessageDigest`.

- Controller cookie policy
  - Refresh tokens are returned in a `refresh_token` cookie with these attributes: HttpOnly, Secure, SameSite=Strict and maxAge ~30 days (the controller uses Duration.ofDays(30) for cookie maxAge). On logout the cookie is cleared (maxAge=0).

- Errors and exceptions
  - Invalid or missing refresh token results in `InvalidRefreshTokenException` (mapped to HTTP 401 by annotation in class).
  - Token corruption (device or IP mismatch) results in `RefreshTokenCorruptionException`.
  - Token reuse and expiry are converted into `InvalidRefreshTokenException` with descriptive messages.

Edge cases and important notes
- Message digest algorithm used to hash refresh tokens is provided as a bean — ensure a secure algorithm (SHA-256 or stronger) is configured.
- Token hashing and Base64 encoding details determine the length of `token_hash`; the DB column allows up to length 64, adjust if you change hash algorithm.
- The quick reuse threshold (5 seconds) is a heuristic; tune to your environment (mobile clients, latency) to avoid false positives.
- Device info and IP checks provide extra protection but may block legitimate clients behind NAT, proxies or with changing IPs; sanitize/normalize headers accordingly.
- `enforceTokenLimit` revokes oldest tokens when user has too many; if you rely on long-lived sessions across devices, choose a reasonable `maxPerUser`.